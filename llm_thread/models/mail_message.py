import json
import markdown2

from odoo import _, fields, models, api
from odoo.exceptions import ValidationError, MissingError, UserError

from odoo.addons.llm_mail_message_subtypes.const import (
    LLM_TOOL_RESULT_SUBTYPE_XMLID,
)

class MailMessage(models.Model):
    _inherit = "mail.message"

    user_vote = fields.Integer(
        string="User Vote",
        default=0,
        help="Vote status given by the user. 0: No vote, 1: Upvoted, -1: Downvoted.",
    )

    @api.constrains("tool_call_id", "subtype_id")
    def _check_tool_message_integrity(self):
        for record in self:
            if record.tool_call_id and record.subtype_id:
                tool_message_subtype = self.env.ref(LLM_TOOL_RESULT_SUBTYPE_XMLID)
                if record.subtype_id.id != tool_message_subtype.id:
                    raise ValidationError(
                        "Tool Call ID can only be set for Tool Messages."
                    )
    
    def _get_llm_message_format_fields(self):
        """Extend the list of fields fetched by the base message_format."""
        fields_list = super()._get_llm_message_format_fields()
        fields_list.extend([
            'tool_calls',
            'tool_call_id',
            'tool_call_definition',
            'tool_call_result',
            'user_vote',
        ])
        return fields_list
    
    def set_user_vote(self, message_id, vote_value): # Add message_id argument
        """
        Finds a message by ID and sets the user vote, performing validation checks.
        Raises MissingError, ValidationError, or UserError if checks fail.
        """
        message = self.env['mail.message'].browse(message_id)
        if not message.exists():
            raise MissingError(_("Message with ID %s not found.") % message_id) # Raise error if not found

        if not isinstance(vote_value, int) or vote_value not in [-1, 0, 1]:
            raise ValidationError(_("Invalid vote value. Must be an integer: 1 (up), -1 (down), or 0 (none)."))

        if message.is_llm_assistant_message() or message.is_llm_tool_result_message():
            message.sudo().write({"user_vote": vote_value})
            return vote_value
        else:
            raise UserError(_("Voting is only allowed on messages generated by the assistant"))
    
    @api.model
    def create_message_from_stream(self, thread, stream, subtype_xmlid, placeholder_text="…"):
        """
        thread: the llm.thread record
        stream: iterator of provider chunks (content/tool_calls/error)
        subtype_xmlid: assistant vs tool result XMLID

        Yields UI events, and finally returns the full message record.
        """
        msg = None
        acc, calls = "", []

        for chunk in stream:
            if msg is None and (chunk.get("content") or chunk.get("tool_calls")):
                msg = thread._post_message(
                    subtype_xmlid=subtype_xmlid,
                    body=placeholder_text,
                    author_id=False,
                )
                yield {"type": "message_create", "message": msg.message_format()[0]}

            if chunk.get("content"):
                acc += chunk["content"]
                msg.write({"body": markdown2.markdown(acc)})
                yield {"type": "message_chunk", "message": msg.message_format()[0]}

            if chunk.get("tool_calls"):
                valid = [c for c in chunk["tool_calls"] if isinstance(c, dict) and c.get("id")]
                calls.extend(valid)
                msg.write({"tool_calls": json.dumps(calls)})
                yield {"type": "message_update", "message": msg.message_format()[0]}

            if chunk.get("error"):
                yield {"type": "error", "error": chunk["error"]}
                return

        # final write & update
        msg.write({
            **({"body": markdown2.markdown(acc)} if acc else {}),
            **({"tool_calls": json.dumps(calls)} if calls else {}),
        })
        yield {"type": "message_update", "message": msg.message_format()[0]}
        return msg

    @api.model
    def stream_llm_tool_result(self, thread, tool_call_def):
        """
        Stream a single tool call:
         1) create a placeholder tool‐result message,
         2) yield the "message_create",
         3) execute the tool,
         4) write the result & yield a "message_update",
         5) return the final message record.
        """
        call_id = tool_call_def.get("id")
        fn      = tool_call_def.get("function", {})
        name    = fn.get("name", "unknown_tool")
        args    = fn.get("arguments")

        # 1) placeholder
        msg = thread._post_message(
            subtype_xmlid=LLM_TOOL_RESULT_SUBTYPE_XMLID,
            tool_call_id=call_id,
            tool_call_definition=json.dumps(tool_call_def),
            tool_call_result=None,
            body=f"Executing: {name}…",
            author_id=False,
            tool_name=name,
        )
        yield {"type": "message_create", "message": msg.message_format()[0]}

        # 2) execute + update
        try:
            # to isolate tool call, otherwise transaction error can cause the transaction to fail
            # and the transaction will be rolled back(aborted state)
            with self.env.cr.savepoint():
                result = thread._execute_tool(name, args)
                if not result:
                    raise UserError(f"No result returned from tool '{name}'")
                body   = f"Result for {name}"
                write_vals = {"tool_call_result": json.dumps(result), "body": body}
        except Exception as e:
            write_vals = {
                "tool_call_result": json.dumps({"error": str(e)}),
                "body": f"Error executing {name}",
            }
        msg.write(write_vals)
        yield {"type": "message_update", "message": msg.message_format()[0]}

        return msg
