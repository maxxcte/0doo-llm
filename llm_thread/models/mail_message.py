import markdown2
import json
from odoo import fields, models, api
from odoo.exceptions import ValidationError

from odoo.addons.llm_mail_message_subtypes.const import (
    LLM_TOOL_RESULT_SUBTYPE_XMLID,
)

class MailMessage(models.Model):
    _inherit = "mail.message"

    user_vote = fields.Integer(
        string="User Vote",
        default=0,
        help="Vote status given by the user. 0: No vote, 1: Upvoted, -1: Downvoted.",
    )

    @api.constrains("tool_call_id", "subtype_id")
    def _check_tool_message_integrity(self):
        for record in self:
            if record.tool_call_id and record.subtype_id:
                tool_message_subtype = self.env.ref(LLM_TOOL_RESULT_SUBTYPE_XMLID)
                if record.subtype_id.id != tool_message_subtype.id:
                    raise ValidationError(
                        "Tool Call ID can only be set for Tool Messages."
                    )
    
    def _get_llm_message_format_fields(self):
        """Extend the list of fields fetched by the base message_format."""
        fields_list = super()._get_llm_message_format_fields()
        fields_list.extend([
            'tool_calls',
            'tool_call_id',
            'tool_call_definition',
            'tool_call_result',
            'user_vote',
        ])
        return fields_list
    
    def set_user_vote(self, message_id, vote_value): # Add message_id argument
        """
        Finds a message by ID and sets the user vote, performing validation checks.
        Raises MissingError, ValidationError, or UserError if checks fail.
        """
        message = self.env['mail.message'].browse(message_id)
        if not message.exists():
            raise MissingError(_("Message with ID %s not found.") % message_id) # Raise error if not found

        if not isinstance(vote_value, int) or vote_value not in [-1, 0, 1]:
            raise ValidationError(_("Invalid vote value. Must be an integer: 1 (up), -1 (down), or 0 (none)."))

        if not message.is_llm_assistant_message(): # Check on the found message
            raise UserError(_("Voting is only allowed on messages generated by the assistant"))

        message.sudo().write({"user_vote": vote_value}) # Write on the found message

        return vote_value
    
    @api.model
    def stream_llm_response(self, thread, stream, subtype_xmlid, placeholder_text="â€¦"):
        """
        thread: the llm.thread record
        stream: iterator of provider chunks (content/tool_calls/error)
        subtype_xmlid: assistant vs tool result XMLID

        Yields UI events, and finally returns the full message record.
        """
        msg = None
        acc, calls = "", []

        for chunk in stream:
            if msg is None and (chunk.get("content") or chunk.get("tool_calls")):
                msg = thread.create_new_message(
                    subtype_xmlid=subtype_xmlid,
                    body=placeholder_text,
                    author_id=False,
                )
                yield {"type": "message_create", "message": msg.message_format()[0]}

            if chunk.get("content"):
                acc += chunk["content"]
                msg.write({"body": markdown2.markdown(acc)})
                yield {"type": "message_chunk", "message": msg.message_format()[0]}

            if chunk.get("tool_calls"):
                valid = [c for c in chunk["tool_calls"] if isinstance(c, dict) and c.get("id")]
                calls.extend(valid)
                msg.write({"tool_calls": json.dumps(calls)})
                yield {"type": "message_update", "message": msg.message_format()[0]}

            if chunk.get("error"):
                yield {"type": "error", "error": chunk["error"]}
                return

        # final write & update
        msg.write({
            **({"body": markdown2.markdown(acc)} if acc else {}),
            **({"tool_calls": json.dumps(calls)} if calls else {}),
        })
        yield {"type": "message_update", "message": msg.message_format()[0]}
        return msg