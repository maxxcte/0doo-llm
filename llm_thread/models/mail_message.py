import emoji
import json
import markdown2

from odoo import fields, models, api
from odoo.exceptions import ValidationError, MissingError, UserError

from odoo.addons.llm_mail_message_subtypes.const import (
    LLM_TOOL_RESULT_SUBTYPE_XMLID,
    LLM_ASSISTANT_SUBTYPE_XMLID,
)

class MailMessage(models.Model):
    _inherit = "mail.message"

    user_vote = fields.Integer(
        string="User Vote",
        default=0,
        help="Vote status given by the user. 0: No vote, 1: Upvoted, -1: Downvoted.",
    )

    @api.constrains("tool_call_id", "subtype_id")
    def _check_tool_message_integrity(self):
        for record in self:
            if record.tool_call_id and record.subtype_id:
                tool_message_subtype = self.env.ref(LLM_TOOL_RESULT_SUBTYPE_XMLID)
                if record.subtype_id.id != tool_message_subtype.id:
                    raise ValidationError(
                        "Tool Call ID can only be set for Tool Messages."
                    )
    
    def _get_llm_message_format_fields(self):
        """Extend the list of fields fetched by the base message_format."""
        fields_list = super()._get_llm_message_format_fields()
        fields_list.extend([
            'tool_calls',
            'tool_call_id',
            'tool_call_definition',
            'tool_call_result',
            'user_vote',
        ])
        return fields_list
    
    def set_user_vote(self, message_id, vote_value): # Add message_id argument
        """
        Finds a message by ID and sets the user vote, performing validation checks.
        Raises MissingError, ValidationError, or UserError if checks fail.
        """
        message = self.env['mail.message'].browse(message_id)
        if not message.exists():
            raise MissingError(_("Message with ID %s not found.") % message_id) # Raise error if not found

        if not isinstance(vote_value, int) or vote_value not in [-1, 0, 1]:
            raise ValidationError(_("Invalid vote value. Must be an integer: 1 (up), -1 (down), or 0 (none)."))

        if not message.is_llm_assistant_message(): # Check on the found message
            raise UserError(_("Voting is only allowed on messages generated by the assistant"))

        message.sudo().write({"user_vote": vote_value}) # Write on the found message

        return vote_value
    
    @api.model
    def stream_llm_response(self, thread, stream, subtype_xmlid, placeholder_text="…"):
        """
        thread: the llm.thread record
        stream: iterator of provider chunks (content/tool_calls/error)
        subtype_xmlid: assistant vs tool result XMLID

        Yields UI events, and finally returns the full message record.
        """
        msg = None
        acc, calls = "", []

        for chunk in stream:
            if msg is None and (chunk.get("content") or chunk.get("tool_calls")):
                msg = thread.create_new_message(
                    subtype_xmlid=subtype_xmlid,
                    body=placeholder_text,
                    author_id=False,
                )
                yield {"type": "message_create", "message": msg.message_format()[0]}

            if chunk.get("content"):
                acc += chunk["content"]
                msg.write({"body": markdown2.markdown(acc)})
                yield {"type": "message_chunk", "message": msg.message_format()[0]}

            if chunk.get("tool_calls"):
                valid = [c for c in chunk["tool_calls"] if isinstance(c, dict) and c.get("id")]
                calls.extend(valid)
                msg.write({"tool_calls": json.dumps(calls)})
                yield {"type": "message_update", "message": msg.message_format()[0]}

            if chunk.get("error"):
                yield {"type": "error", "error": chunk["error"]}
                return

        # final write & update
        msg.write({
            **({"body": markdown2.markdown(acc)} if acc else {}),
            **({"tool_calls": json.dumps(calls)} if calls else {}),
        })
        yield {"type": "message_update", "message": msg.message_format()[0]}
        return msg

    @api.model
    def stream_llm_tool_result(self, thread, tool_call_def):
        """
        Stream a single tool call:
         1) create a placeholder tool‐result message,
         2) yield the "message_create",
         3) execute the tool,
         4) write the result & yield a "message_update",
         5) return the final message record.
        """
        call_id = tool_call_def.get("id")
        fn      = tool_call_def.get("function", {})
        name    = fn.get("name", "unknown_tool")
        args    = fn.get("arguments")

        # 1) placeholder
        msg = thread.create_new_message(
            subtype_xmlid=LLM_TOOL_RESULT_SUBTYPE_XMLID,
            tool_call_id=call_id,
            tool_call_definition=json.dumps(tool_call_def),
            tool_call_result=None,
            body=f"Executing: {name}…",
            author_id=False,
            tool_name=name,
        )
        yield {"type": "message_create", "message": msg.message_format()[0]}

        # 2) execute + update
        try:
            resp = thread._execute_tool(name, args, call_id)
            result = resp.get("result", json.dumps({"error": "no result"}))
            body   = f"Result for {name}"
            write_vals = {"tool_call_result": result, "body": body}
        except Exception as e:
            write_vals = {
                "tool_call_result": json.dumps({"error": str(e)}),
                "body": f"Error executing {name}",
            }
        msg.write(write_vals)
        yield {"type": "message_update", "message": msg.message_format()[0]}

        return msg

    @api.model
    def validate_subtype(self, xmlid):
        """Ensure subtype XML ID exists or raise."""
        try:
            subtype = self.env.ref(xmlid)
        except ValueError:
            raise MissingError(f"Subtype '{xmlid}' not found.")
        if not subtype.exists():
            raise MissingError(f"Subtype '{xmlid}' not found.")
        return subtype

    @staticmethod
    def get_email_from(provider_name, provider_model_name, subtype_xmlid, author_id, tool_name=None):
        if not author_id:    
            if subtype_xmlid == LLM_TOOL_RESULT_SUBTYPE_XMLID:
                name = tool_name or 'Tool'
                return f"{name} <tool@{provider_name.lower().replace(' ', '')}.ai>"
            elif subtype_xmlid == LLM_ASSISTANT_SUBTYPE_XMLID:
                model = provider_model_name or 'Assistant'
                provider = provider_name.lower().replace(' ', '')
                return f"{model} <ai@{provider}.ai>"
            else:
                return None
        return None

    @staticmethod
    def build_post_vals(subtype_xmlid, body, author_id, email_from):
        return {
            'body': markdown2.markdown(emoji.demojize(body)),
            'message_type': 'comment',
            'subtype_xmlid': subtype_xmlid,
            'author_id': author_id,
            'email_from': email_from or None,
            'partner_ids': [],
        }

    @staticmethod
    def build_update_vals(subtype_xmlid, tool_call_id=None, tool_calls=None, tool_call_definition=None, tool_call_result=None):
        if subtype_xmlid == LLM_ASSISTANT_SUBTYPE_XMLID and tool_calls:
            return {'tool_calls': tool_calls}
        if subtype_xmlid == LLM_TOOL_RESULT_SUBTYPE_XMLID:
            vals = {
                'tool_call_id': tool_call_id,
                'tool_call_definition': tool_call_definition,
                'tool_call_result': tool_call_result,
            }
            return {k: v for k, v in vals.items() if v is not None}
        return {}